---
title : "SURICATA"
image : "/assets/images/post/suricata.jpg"
author : "Vaishakh"
date: 2025-05-24 13:07:58 +0600
description : "A blog on Fundamentals of Suricata"
tags : ["IDPS"]
---
If you’re diving into network security, let me walk you through how I use Suricata and why it’s become such a staple in my toolkit. Suricata, developed by the Open Information Security Foundation (OISF), is an open-source powerhouse for anyone serious about monitoring and protecting their network. What makes it stand out is its ability to function as an Intrusion Detection System (IDS), Intrusion Prevention System (IPS), and Network Security Monitoring (NSM) tool—all rolled into one.

Suricata Fundamentals Explained

**Why Suricata?** 

When I set up Suricata, my main goal is to scrutinize every bit of network traffic for signs of trouble. Suricata’s strength lies in its deep packet inspection—it doesn’t just skim the surface but digs into the content of each packet to catch threats that might otherwise slip by. Thanks to its multi-threaded design, I can deploy it on anything from standard hardware to specialized setups and still get high performance.

**How Suricata Works**

At the heart of Suricata’s operation is its rule set. These rules guide the engine, telling it what to look for and how to react. I can customize these rules or use community-contributed ones, making it easy to tailor Suricata to my network’s unique needs. The flexibility here is key—whether I’m after signature-based detection, anomaly detection, or protocol analysis, Suricata has me covered.

**Suricata’s Four Modes: How I Use Them**

Suricata isn’t a one-trick pony; it operates in four main modes, each serving a different purpose:

**IDS Mode:**

When I want to observe without interfering, I run Suricata in IDS mode. Here, it quietly monitors traffic, flags suspicious activity, and sends alerts. It’s great for getting a sense of what’s happening on the network without risking any accidental disruptions.

**IPS Mode:**

For a more hands-on approach, I switch to IPS mode. Now, Suricata isn’t just watching—it’s actively blocking malicious traffic before it can do any harm. This is perfect when I need real-time protection, but it does require careful rule management to avoid false positives that could block legitimate users.

**IDPS Mode:**

Sometimes, I want a balance between passive monitoring and active defense. In IDPS mode, Suricata still observes but can also take limited action, like sending RST packets to disrupt suspicious connections. This strikes a good compromise between security and network performance.

**NSM Mode:**

When detailed records are what I need, I use NSM mode. Suricata logs everything it sees—HTTP requests, DNS queries, TLS metadata, and more. This creates a rich dataset for later analysis, which is invaluable for incident response or forensic investigations.

**Feeding Suricata: Inputs I Use**

Suricata can process traffic in two main ways:

**Offline Input:**

If I’m analyzing past events or testing new rule sets, I feed Suricata PCAP files. This lets me replay and examine previously captured traffic without impacting the live network.

**Live Input:**

For real-time monitoring, I use live input via LibPCAP, NFQ, or AF_PACKET. LibPCAP is straightforward but not the fastest. When performance matters, AF_PACKET offers multi-threading and better speed, though it has some compatibility caveats. For inline blocking, especially on Linux, NFQ works with IPTables to route packets through Suricata for inspection and possible blocking.

**Getting Results: Suricata Outputs**

Suricata’s outputs are as versatile as its inputs. The most important for me is the EVE JSON log—it captures alerts, HTTP, DNS, TLS, and more in a format that’s easy to feed into tools like Logstash for further analysis.

**Getting Started with Suricata**

*Installation*

Inorder to run and test Suricata you can go through their official [documentation].

[documentation]: https://docs.suricata.io/en/latest/quickstart.html

**Understanding a Suricata Rule**

Let’s walk through the anatomy of a Suricata rule, breaking down each piece as if we’re examining it together for the first time. Here’s a sample rule I’ll use for illustration:

{% highlight ruby %}
alert tcp $HOME_NET any -> $EXTERNAL_NET 8080 (msg:"Suspicious outbound HTTP POST detected"; flow:established,to_server; content:"POST"; http.method; content:"/upload"; http.uri; nocase; sid:2000001; rev:2;)
{% endhighlight %}

*1.Rule Structure: The Big Picture*

Every Suricata rule is composed of three main parts: the action, the header, and the options. Each plays a distinct role in telling Suricata what to look for and how to react when it finds something interesting

*2. The Action*

The very first word in the rule, alert, is the action. This tells Suricata what to do when traffic matches the rule. Actions can be:

 `alert`: Generate an alert.

 `log`: Record the event without alerting.

 `pass`: Ignore the packet.

 `drop`: Block the packet (in IPS mode).

 `reject`: Block and actively notify the sender (e.g., with a TCP reset).

In our example, alert means Suricata will generate an alert if the rule matches.

*3. The Header*

Next comes the header, which looks like this:

{% highlight ruby %}
tcp $HOME_NET any -> $EXTERNAL_NET 8080
{% endhighlight %}

This section sets the stage for what kind of traffic we’re interested in:

Protocol: Here, it’s `tcp`, but it could also be `udp`, `icmp`, `ip`, or even application-specific like `http`.

Source and Destination: `$HOME_NET` and `$EXTERNAL_NET` are variables (set elsewhere, usually in `suricata.yaml`) representing internal and external networks. You could also use specific IPs or any.

Ports: `any` for the source port, `8080` for the destination port. You can specify single ports, lists, or ranges.

Direction: The arrow `->` shows the direction of traffic. For bidirectional rules, you’d use `<>`.

So, this header matches any TCP traffic from inside your network to an external address on port 8080.

*4. Rule Options*

Everything inside the parentheses is a rule option, providing the details Suricata uses to decide if a packet is interesting enough to trigger the action.

Let’s break down the options in our example:

`msg:"Suspicious outbound HTTP POST detected";` This is the message shown when the rule triggers. It should be descriptive enough for analysts to quickly understand the context.

`flow:established,to_server;` This tells Suricata to only consider packets that are part of an established connection and are going to the server.

`content:"POST"; http.method;` `content:"/upload"; http.uri;` These look for the string "POST" in the HTTP method and "/upload" in the URI. The http.method and http.uri are sticky buffers, meaning Suricata only searches those specific parts of the HTTP request, making matching more efficient.

`nocase;` This makes the content match case-insensitive, so "post", "POST", or "Post" would all match.

`sid:2000001; rev:2;` The signature ID (sid) uniquely identifies the rule, while rev is the revision number, useful for tracking changes over time.

*5. Advanced Matching*

Suricata rules can include other options for more precise detection:

`offset/depth`: Control where in the payload to search for content.

`distance/within`: Specify how far apart content matches must be.

`dsize`:` Match based on the size of the packet payload.

`reference`: Link to documentation or sources for the rule.

Example:

{% highlight ruby %}
alert tcp any any -> any 22 (msg:"SSH brute-force attempt detected"; flow:to_server,established; content:"SSH-"; offset:0; depth:4; dsize:>100; sid:2000002; rev:1;)
This rule looks for large packets starting with "SSH-" on port 22, possibly indicating brute-force attempts.
{% endhighlight %}

**Summary**

Suricata rules are powerful because they allow you to define exactly what network activity you care about, and what to do when you see it. By combining actions, headers, and options, you can craft highly specific and effective detections that help secure your network.

*“Each option keyword adds a layer of sophistication to the detection logic, enabling the creation of highly specific and context-aware security rules.”*

Mastering Suricata rule syntax is key to unlocking the full potential of this security tool. The more you experiment and refine your rules, the better you’ll become at spotting threats and minimizing false alarms.